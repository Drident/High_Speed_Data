-- VHDL Entity Bachelor_test.mainCircuit_tb.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 17:12:03 15.05.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY mainCircuit_tb IS
-- Declarations

END mainCircuit_tb ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity Bachelor.mainCircuit.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 09:49:50 05.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY mainCircuit IS
    GENERIC( 
        g_clockFrequency : real := 64.0E6
    );
    PORT( 
        acq_pretrig : IN     std_ulogic;
        acq_trig    : IN     std_ulogic;
        adc_sdo     : IN     std_ulogic_vector (3 DOWNTO 0);
        clk         : IN     std_ulogic;
        clk_en      : IN     std_ulogic;
        fpga_m      : IN     std_ulogic_vector (3 DOWNTO 0);
        fpga_mosi   : IN     std_ulogic;
        fpga_sck    : IN     std_ulogic;
        rst         : IN     std_uLogic;
        adc_nsc     : OUT    std_ulogic;
        adc_sclk    : OUT    std_ulogic;
        cal         : OUT    std_ulogic_vector (2 DOWNTO 1);
        fpga_miso   : OUT    std_ulogic;
        fram_ncs    : OUT    std_ulogic_vector (3 DOWNTO 0);
        fram_sclk   : OUT    std_ulogic_vector (3 DOWNTO 0);
        fram_sdi    : OUT    std_ulogic_vector (3 DOWNTO 0);
        meas_1mhz   : OUT    std_ulogic;
        out1        : OUT    std_uLogic;
        sclk_meas   : OUT    std_ulogic
    );

-- Declarations

END mainCircuit ;





-- VHDL Entity Bachelor.ADC_Write.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 09:08:10 22.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY ADC_Write IS
    PORT( 
        FPGA_clock : IN     std_ulogic;
        SDO        : IN     std_ulogic_vector (3 DOWNTO 0);
        clock      : IN     std_ulogic;
        m          : IN     std_ulogic_vector (3 DOWNTO 0);
        reset      : IN     std_ulogic;
        AW_CLOCK   : OUT    std_ulogic;
        MISO       : OUT    std_ulogic;
        NCs        : OUT    std_ulogic
    );

-- Declarations

END ADC_Write ;





--
-- VHDL Architecture Bachelor.ADC_Write.STUDENT_V2
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 09:05:42 22.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE STUDENT_V2 OF ADC_Write IS
	signal count: unsigned(5 downto 0);
	signal go : std_uLogic;
	signal MISO_IN : std_uLogic;
	signal clockOut : std_uLogic;
	signal clockGO : std_uLogic;
BEGIN
	spiMS: process(m, SDO)
	  begin
	    if m < "0100" and m > "0000" then
			NCS <= '0';
			MISO_IN <= SDO(SDO'high);
		else
			NCS <= '1';
			MISO_IN <= '0';
	    end if;
	  end process spiMS;

	colckCounter: process(reset, clock)
		begin
			if reset = '1' then
				count <= (others => '0');
				go <= '0' ;
			elsif rising_edge(clock) then
				 if unsigned(m) <= "0010" and unsigned(m) >= "0001" 
				 								and count /= 17 then 
				 	if FPGA_clock = '1' and go = '0' then
				 		count <= count +1 ;
				 		go <= '1';
				 	elsif FPGA_clock = '0' then
				 		go <= '0';
				 	end if;
				 elsif unsigned(m) = "0000" or unsigned(m) > "0010" then
				 	count <= (others => '0');
				 end if;
			end if ;
		end process colckCounter;

	colckSwitch: process(FPGA_clock)
		begin
			if unsigned(m) <= "0010" and unsigned(m) >= "0001" 
				 								and count /= 17 then
				clockOut <= FPGA_clock;
			else
				clockOut <= '1';
			end if ;
		end process colckSwitch;
	AW_CLOCK <= clockOut;
	MISO <= MISO_IN;
END ARCHITECTURE STUDENT_V2;





-- VHDL Entity Bachelor.cont_done.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 11:19:46 07.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY cont_done IS
    GENERIC( 
        memory_size : positive := 19;
        delay       : time     := gateDelay
    );
    PORT( 
        Trigg       : IN     std_ulogic;
        clock       : IN     std_ulogic;
        go          : IN     std_ulogic;
        preTriggVal : IN     unsigned (7 DOWNTO 0);
        reset       : IN     std_ulogic;
        Memory      : OUT    unsigned (18 DOWNTO 0);
        done        : OUT    std_ulogic
    );

-- Declarations

END cont_done ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




--
-- VHDL Architecture Bachelor.cont_done.test
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 15:10:10 30.05.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY Common;
  USE Common.CommonLib.all;

ARCHITECTURE test OF cont_done IS
    signal memoryTrig : unsigned((memory_size-1) downto 0);
    signal count_memory: unsigned((memory_size-1) downto 0);
    signal count_preTrig: unsigned((memory_size-1) downto 0);
    signal done_wait : unsigned(3 downto 0);
    constant wait_time          : natural := 4;
BEGIN
  done_Counter: process(reset, clock)
  begin
    if reset = '1' then
      memoryTrig <= (others => '1');
      count_preTrig <= (others => '0');
      count_memory <= (others => '0');
      done_wait <= (others => '0');
      done <= '0';
      Memory <= (others => '0');
    elsif rising_edge(clock) then
      if go = '1' then
        if Trigg = '0' and count_preTrig = 0  then 
          count_memory <= count_memory+1 ;
        elsif Trigg = '1' and count_preTrig = 0 then
          memoryTrig <= resize((memoryTrig/to_unsigned(100,memoryTrig'length))
                                             *preTriggVal,memoryTrig'length);
          if count_preTrig /= memoryTrig then
            count_memory <= count_memory+1 ;  
            count_preTrig <= count_preTrig+1;
          end if ;
        elsif count_preTrig >0 then
            if count_preTrig /= memoryTrig then
              count_memory <= count_memory+1 ;  
              count_preTrig <= count_preTrig+1;
          end if ;
        end if;

      elsif count_preTrig = memoryTrig and done = '0' then
          done <= '1';
          Memory <= count_memory;
      elsif done = '1' then
          count_preTrig <= (others => '0');
          count_memory <= (others => '0');
          done_wait <= done_wait+1 ;
          if done_wait = wait_time then
            done_wait <= (others => '0');
            done <= '0';
          end if;
      end if;
    end if;
  end process done_Counter;

END ARCHITECTURE test;





-- VHDL Entity sequential.freqDivider.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:18 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY freqDivider IS
    GENERIC( 
        divideValue : positive := 256;
        delay       : time     := gateDelay
    );
    PORT( 
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        enable : OUT    std_ulogic
    );

-- Declarations

END freqDivider ;





LIBRARY Common;
  USE Common.CommonLib.all;

ARCHITECTURE RTL OF freqDivider IS

  signal count: unsigned(requiredBitNb(divideValue)-1 downto 0);

BEGIN

  countEndlessly: process(reset, clock)
  begin
    if reset = '1' then
      count <= (others => '0');
    elsif rising_edge(clock) then
      if count = 0 then
        count <= to_unsigned(divideValue-1, count'length);
      else
        count <= count-1 ;
      end if;
    end if;
  end process countEndlessly;

  enable <= '1' after delay when count = 0
    else '0' after delay;

END ARCHITECTURE RTL;




-- VHDL Entity sequential.TFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:18 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY TFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        T   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END TFF ;





ARCHITECTURE sim OF TFF IS

  signal q_int: std_ulogic;

BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q_int <= '0' after delay;
    elsif rising_edge(clk) then
      q_int <= t xor q_int after delay;
    end if;
  end process;

  q <= q_int;

END sim;




-- VHDL Entity Bachelor.PRETRIG_VALUE.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 11:01:57 06.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY PRETRIG_VALUE IS
    PORT( 
        clock           : IN     std_ulogic;
        m               : IN     std_ulogic_vector (3 DOWNTO 0);
        preTrigger      : IN     std_ulogic;
        reset           : IN     std_ulogic;
        preTriggerValue : OUT    unsigned (7 DOWNTO 0)
    );

-- Declarations

END PRETRIG_VALUE ;





--
-- VHDL Architecture Bachelor.PRETRIG_VALUE.STUDENT
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 13:12:09 05.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE STUDENT OF PRETRIG_VALUE IS
  signal count_pre: unsigned(3 downto 0);
  signal valuePreTrig: unsigned(7 downto 0);

BEGIN
  value_of_preTrig: process(reset, clock)
  begin
    if reset = '1' then
      count_pre <= (others => '0');
      valuePreTrig <= (others => '0');
    elsif rising_edge(clock) then
      if m = "1110" then
      	if count_pre = 0 and preTrigger = '1' then
      		count_pre <= count_pre+1 ;
      		--valuePreTrig(0) <= preTrigger ;
      	elsif count_pre < 8 and count_pre > 0 then
      		count_pre <= count_pre+1 ;
      		valuePreTrig <= SHIFT_LEFT(valuePreTrig,1);
      		valuePreTrig(0) <= preTrigger;
      	end if ;
      else
        count_pre <= (others => '0');
      end if;
    end if;
  end process value_of_preTrig;

preTriggerValue <= valuePreTrig;
END ARCHITECTURE STUDENT;





-- VHDL Entity Bachelor.memory_to_process.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 10:45:00 13.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY memory_to_process IS
    GENERIC( 
        memory_size : positive := 19
    );
    PORT( 
        clock     : IN     std_ulogic;
        m         : IN     std_ulogic_vector (3 DOWNTO 0);
        memoryAdd : IN     unsigned (18 DOWNTO 0);
        reset     : IN     std_ulogic;
        MISO      : OUT    std_ulogic
    );

-- Declarations

END memory_to_process ;





--
-- VHDL Architecture Bachelor.memory_to_process.student
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 10:24:22 07.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY Common;
  USE Common.CommonLib.all;
ARCHITECTURE student OF memory_to_process IS
	signal count: unsigned((memory_size-1) downto 0);
	signal count_memory: unsigned((memory_size-1) downto 0);
	signal start_bit: std_uLogic;
	signal MISO_IN: std_uLogic;
	signal done_int: std_uLogic := '0';
BEGIN
	sendAdd : process(reset, clock)
	begin
		if reset = '1' then
			start_bit <= '0';
			MISO_IN <= '0';
 			count_memory <= (others => '0');
	    count <= (others => '0');
		elsif rising_edge(clock) then
			if m = "1011" then
					if start_bit = '0' then
			          MISO_IN <= '1';
			          start_bit <= '1';
			          count_memory <= memoryAdd;
			    elsif count < memory_size and start_bit = '1' then
			          count <= count+1;
			          MISO_IN <= count_memory(count_memory'HIGH);
			          count_memory <= SHIFT_LEFT(count_memory,1);
			    elsif count = memory_size then
			          count_memory <= (others => '0');
			          MISO_IN <= '0';
			    end if ;
	    else
	    			start_bit <= '0';
	    			count <= (others => '0');
	    end if;
	      	
		end if ;
	end process sendAdd;
	
	MISO <= MISO_IN;
END ARCHITECTURE student;





-- VHDL Entity Bachelor.FRAM_WriteRead.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 08:35:34 22.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY FRAM_WriteRead IS
    PORT( 
        FPGA_clock : IN     std_logic;
        MOSI       : IN     std_ulogic;
        clock      : IN     std_ulogic;
        m          : IN     std_ulogic_vector (3 DOWNTO 0);
        reset      : IN     std_ulogic;
        NCs        : OUT    std_ulogic_vector (3 DOWNTO 0);
        SCLK_OUT   : OUT    std_ulogic_vector (3 DOWNTO 0);
        SDI        : OUT    std_ulogic_vector (3 DOWNTO 0)
    );

-- Declarations

END FRAM_WriteRead ;





--
-- VHDL Architecture Bachelor.FRAM_WriteRead.STUDEBT_V2
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 08:32:03 22.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE STUDENT_V2 OF FRAM_WriteRead IS
	signal go 		 		   : std_uLogic;
	signal count 			   : unsigned(7 downto 0);
	signal countValue 		   : unsigned(7 downto 0);
	signal sclk_in	 		   : std_uLogic_vector(3 downto 0);
	constant value_8           : natural := 8;
	constant value_32          : natural := 32;
BEGIN
	spiMS: process(MOSI,m)
	  begin
	    if m = "0100" then 
			NCs <= "1110";
			SDI <= (others => '0');
			SDI(SDI'high-3) <= MOSI;
	    elsif m = "0101" then
	    	NCs <= "1101";
	    	SDI <= (others => '0');
	    	SDI(SDI'high-2) <= MOSI;
	    elsif m = "0110" then
	    	NCs <= "1011";
	    	SDI <= (others => '0');
	    	SDI(SDI'high-1) <= MOSI;
	    elsif m = "0111" then
	    	NCs <= "0111";
	    	SDI <= (others => '0');
	    	SDI(SDI'high) <= MOSI;
	    elsif m = "1000" then
	    	NCs <= (others => '0');
	    	SDI(SDI'high) <= MOSI;
	    	SDI(SDI'high-1) <= MOSI;
	    	SDI(SDI'high-2) <= MOSI;
	    	SDI(SDI'high-3) <= MOSI;
	    else
	    	NCs <= (others => '1');
			SDI <= (others => '0');
	    end if;
	  end process spiMS;

	colckCounter: process(reset, clock)
		begin
			if reset = '1' then
				count <= (others => '0');
				go <= '0' ;
			elsif rising_edge(clock) then
				 if unsigned(m) = "1000" and count <= value_32 then
				 	if FPGA_clock = '1' and go = '0' then
				 		count <= count +1 ;
				 		go <= '1';
				 	elsif FPGA_clock = '0' then
				 		go <= '0';
				 	end if;
				 elsif unsigned(m) > "1000" or unsigned(m) < "0100" then
				 	count <= (others => '0');
				 end if;
			end if ;
		end process colckCounter;

	colckSwitch: process(FPGA_clock)
		begin
			if unsigned(m) = "1000" and count <= value_32 then
				sclk_in(sclk_in'high) <= FPGA_clock;
				sclk_in(sclk_in'high-1) <= FPGA_clock;
				sclk_in(sclk_in'high-2) <= FPGA_clock;
				sclk_in(sclk_in'high-3) <= FPGA_clock;
			elsif unsigned(m) < "1000" and unsigned(m) >= "0100" then
				sclk_in(sclk_in'high) <= FPGA_clock;
				sclk_in(sclk_in'high-1) <= FPGA_clock;
				sclk_in(sclk_in'high-2) <= FPGA_clock;
				sclk_in(sclk_in'high-3) <= FPGA_clock;				
			else
				sclk_in <= (others =>'1');
			end if ;
		end process colckSwitch;

	SCLK_OUT<= sclk_in;
END ARCHITECTURE STUDENT_V2;





-- VHDL Entity Bachelor.MAIN_MUX.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 15:28:48 05.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY MAIN_MUX IS
    PORT( 
        AF_CLOCK     : IN     std_ulogic_vector (3 DOWNTO 0);
        AF_CLOCK_ADC : IN     std_ulogic;
        AF_FRAM_SDI  : IN     std_ulogic_vector (3 DOWNTO 0);
        AF_MISO      : IN     std_ulogic;
        AF_NCS_A     : IN     std_ulogic;
        AF_NCS_F     : IN     std_ulogic_vector (3 DOWNTO 0);
        AW_CLOCK     : IN     std_ulogic;
        AW_MISO      : IN     std_ulogic;
        AW_NCS_A     : IN     std_ulogic;
        FW_CLOCK     : IN     std_ulogic_vector (3 DOWNTO 0);
        FW_FRAM_SDI  : IN     std_ulogic_vector (3 DOWNTO 0);
        FW_NCS_F     : IN     std_ulogic_vector (3 DOWNTO 0);
        M            : IN     std_ulogic_vector (3 DOWNTO 0);
        ADC_CLOCK    : OUT    std_ulogic;
        ADC_NCS      : OUT    std_ulogic;
        FRAM_SDI     : OUT    std_ulogic_vector (3 DOWNTO 0);
        FR_CLOCK     : OUT    std_ulogic_vector (3 DOWNTO 0);
        FR_NCS       : OUT    std_ulogic_vector (3 DOWNTO 0);
        MISO         : OUT    std_ulogic
    );

-- Declarations

END MAIN_MUX ;





--
-- VHDL Architecture Bachelor.MAIN_MUX.STUDENT
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 13:08:20 31.05.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE STUDENT OF MAIN_MUX IS
BEGIN
	mux: process(FW_NCS_F,AF_CLOCK,AF_CLOCK_ADC,FW_CLOCK,AW_CLOCK,
									AW_NCS_A,AF_NCS_A,M,AF_MISO)
	-- WARNING IF ERROR IN PHYSIC -> SWITCH CASE METHODE ALEX
	begin
		case M is
			-- init
			when "0000" =>	
				ADC_CLOCK <=  '1';
				FR_CLOCK <= (others => '0');
				ADC_NCS <= '1';
				FR_NCS <= (others => '1');
				FRAM_SDI <= (others => '0');
				MISO <= '0';		
			-- Read/Write ADC
			when "0001" =>	
				ADC_CLOCK <= AW_CLOCK;
				--FR_CLOCK <= (others => '0');
				ADC_NCS <= AW_NCS_A;
				FR_NCS <= (others => '1');
				--FRAM_SDI <= (others => '0');
				MISO <= AW_MISO;

			-- ADC to FRAM
			when "1010" =>
				ADC_CLOCK <= AF_CLOCK_ADC;
				FR_CLOCK <= AF_CLOCK;
				ADC_NCS <= AF_NCS_A;
				FR_NCS <= AF_NCS_F;
				FRAM_SDI <= AF_FRAM_SDI;
				MISO <= AF_MISO;

			-- ADC to FRAM
			when "1011" =>
				ADC_CLOCK <= '1';
				FR_CLOCK <= (others => '1');
				ADC_NCS <= '1';
				FR_NCS <= (others => '1');
				FRAM_SDI <= (others => '0');
				MISO <= AF_MISO;
				
			-- read/write FRAM
			when others =>
				if M <= "1000" and M >="0100" then
					--ADC_CLOCK <= '0';
					FR_CLOCK <= FW_CLOCK;
					ADC_NCS <= '1';
					FR_NCS <= FW_NCS_F;
					FRAM_SDI <= FW_FRAM_SDI;
					--MISO <= '0';
				else
					FR_NCS <= (others => '1');
					ADC_NCS <= '1';
					ADC_CLOCK <=  '1';
					FR_CLOCK <= (others => '1');
				end if;
			end case;
	end process mux;
END ARCHITECTURE STUDENT;





-- VHDL Entity Bachelor.ADC_TO_FPGA.symbol
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 13:54:20 05.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

ENTITY ADC_TO_FPGA IS
    GENERIC( 
        counter_length : positive := 19
    );
    PORT( 
        clock      : IN     std_ulogic;
        clock_1m   : IN     std_ulogic;
        done_sig   : IN     std_ulogic;
        m          : IN     std_ulogic_vector (3 DOWNTO 0);
        reset      : IN     std_ulogic;
        sdo        : IN     std_ulogic_vector (3 DOWNTO 0);
        adc_clock  : OUT    std_ulogic;
        count_go   : OUT    std_ulogic;
        fram_clock : OUT    std_ulogic_vector (3 DOWNTO 0);
        ncs_adc    : OUT    std_ulogic;
        ncs_fram   : OUT    std_ulogic_vector (3 DOWNTO 0);
        sdi        : OUT    std_ulogic_vector (3 DOWNTO 0)
    );

-- Declarations

END ADC_TO_FPGA ;





--
-- VHDL Architecture Bachelor.ADC_TO_FPGA.STUDENT
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 11:23:31 31.05.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY Common;
  USE Common.CommonLib.all;

ARCHITECTURE STUDENT OF ADC_TO_FPGA IS
	  signal done16 : std_uLogic ;
	  signal down_ncs : std_uLogic ;
	  signal down_ncs_old : std_uLogic ;
	  signal is_up : std_uLogic ;
	  signal finish_d : std_uLogic ;
	  signal count: unsigned(requiredBitNb(counter_length)-1 downto 0);
BEGIN
	adc_to_fpga: process(clock,reset)
	begin
		if reset = '1' then
			fram_clock <= (others => '1');
			adc_clock <= '1';
			finish_d <= '0';
			sdi <= (others => '0');
			ncs_fram <= (others => '0');
			ncs_adc <= '1';
			done16 <= '0';
			count <= (others => '0');
			is_up <= '1';
			count_go <= '0';
			down_ncs_old <= '1';
		elsif rising_edge(clock) then
			--if m = "0010" and down_ncs = '0' then
			count_go <= '0';
			if down_ncs /= down_ncs_old and m = "1010" and finish_d = '0' then
				down_ncs_old <= down_ncs;
				is_up <= '0';
			elsif is_up = '0' and finish_d = '0' and m = "1010" then
				ncs_fram <= (others => '0');
				ncs_adc <= '0';
				if count >= 1 and count <= counter_length-3 then
					if count = 8 and count_go = '0' then
						count_go <= '1';
					end if;

					if adc_clock = '1' then 
						adc_clock <= '0';
						fram_clock <= (others => '0');
					else
						adc_clock <= '1';
						fram_clock <= (others => '1');
						sdi <= sdo;
						count <= count + 1;
					end if;
				elsif count = counter_length-2 then
					count_go <= '1';
					adc_clock <= '1';
					fram_clock <= (others => '1');
					count <= count+1 ;
				elsif count = counter_length-1 then
					is_up <= '1';
					ncs_adc <= '1';
					ncs_fram <= (others => '0');
				elsif count = 0 then
					count <= count + 1;
				end if ;
			else 
				count <= (others => '0');
			end if;

			if done_sig = '1' then
				finish_d <= '1';
				ncs_fram <= (others => '1');
				ncs_adc <= '1';
			elsif m /= "1010" then
				finish_d <= '0';
			end if ;

		end if;
	end process adc_to_fpga;

	NCS_clock: process(clock_1m,reset)
	begin
		if reset = '1' then
			down_ncs <= '1';
		elsif rising_edge(clock_1m) then
			--if m = "0010" then
			if down_ncs = '1' and m = "1010" then
				down_ncs <= '0';
			else
				down_ncs <= '1';
			end if; 
		end if;
	end process NCS_clock;

END ARCHITECTURE STUDENT;





-- VHDL Entity gates.bufferUlogic.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:48 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY bufferUlogic IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END bufferUlogic ;





ARCHITECTURE sim OF bufferUlogic IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




--
-- VHDL Architecture Bachelor.mainCircuit.struct
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 09:20:32 22.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY gates;
  USE gates.gates.all;

LIBRARY Bachelor;
LIBRARY sequential;

ARCHITECTURE struct OF mainCircuit IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL AW_CLOCK        : std_ulogic;
    SIGNAL MISO_AF         : std_ulogic;
    SIGNAL MISO_AW         : std_ulogic;
    SIGNAL Memory          : unsigned(18 DOWNTO 0);
    SIGNAL T               : std_uLogic;
    SIGNAL adc_nscAF       : std_ulogic;
    SIGNAL adc_nscAW       : std_ulogic;
    SIGNAL adc_sclkAF      : std_ulogic;
    SIGNAL count_go        : std_ulogic;
    SIGNAL done            : std_ulogic;
    SIGNAL enable          : std_ulogic;
    SIGNAL fram_ncsAF      : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL fram_ncsFW      : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL fram_sclkAF     : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL fram_sclkFW     : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL fram_sdiAF      : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL fram_sdiFW      : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL preTriggerValue : unsigned(7 DOWNTO 0);

    -- Implicit buffer signal declarations
    SIGNAL meas_1mhz_internal : std_ulogic;


    -- Component Declarations
    COMPONENT ADC_TO_FPGA
    GENERIC (
        counter_length : positive := 19
    );
    PORT (
        clock      : IN     std_ulogic ;
        clock_1m   : IN     std_ulogic ;
        done_sig   : IN     std_ulogic ;
        m          : IN     std_ulogic_vector (3 DOWNTO 0);
        reset      : IN     std_ulogic ;
        sdo        : IN     std_ulogic_vector (3 DOWNTO 0);
        adc_clock  : OUT    std_ulogic ;
        count_go   : OUT    std_ulogic ;
        fram_clock : OUT    std_ulogic_vector (3 DOWNTO 0);
        ncs_adc    : OUT    std_ulogic ;
        ncs_fram   : OUT    std_ulogic_vector (3 DOWNTO 0);
        sdi        : OUT    std_ulogic_vector (3 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT ADC_Write
    PORT (
        FPGA_clock : IN     std_ulogic ;
        SDO        : IN     std_ulogic_vector (3 DOWNTO 0);
        clock      : IN     std_ulogic ;
        m          : IN     std_ulogic_vector (3 DOWNTO 0);
        reset      : IN     std_ulogic ;
        AW_CLOCK   : OUT    std_ulogic ;
        MISO       : OUT    std_ulogic ;
        NCs        : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT FRAM_WriteRead
    PORT (
        FPGA_clock : IN     std_logic ;
        MOSI       : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        m          : IN     std_ulogic_vector (3 DOWNTO 0);
        reset      : IN     std_ulogic ;
        NCs        : OUT    std_ulogic_vector (3 DOWNTO 0);
        SCLK_OUT   : OUT    std_ulogic_vector (3 DOWNTO 0);
        SDI        : OUT    std_ulogic_vector (3 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT MAIN_MUX
    PORT (
        AF_CLOCK     : IN     std_ulogic_vector (3 DOWNTO 0);
        AF_CLOCK_ADC : IN     std_ulogic ;
        AF_FRAM_SDI  : IN     std_ulogic_vector (3 DOWNTO 0);
        AF_MISO      : IN     std_ulogic ;
        AF_NCS_A     : IN     std_ulogic ;
        AF_NCS_F     : IN     std_ulogic_vector (3 DOWNTO 0);
        AW_CLOCK     : IN     std_ulogic ;
        AW_MISO      : IN     std_ulogic ;
        AW_NCS_A     : IN     std_ulogic ;
        FW_CLOCK     : IN     std_ulogic_vector (3 DOWNTO 0);
        FW_FRAM_SDI  : IN     std_ulogic_vector (3 DOWNTO 0);
        FW_NCS_F     : IN     std_ulogic_vector (3 DOWNTO 0);
        M            : IN     std_ulogic_vector (3 DOWNTO 0);
        ADC_CLOCK    : OUT    std_ulogic ;
        ADC_NCS      : OUT    std_ulogic ;
        FRAM_SDI     : OUT    std_ulogic_vector (3 DOWNTO 0);
        FR_CLOCK     : OUT    std_ulogic_vector (3 DOWNTO 0);
        FR_NCS       : OUT    std_ulogic_vector (3 DOWNTO 0);
        MISO         : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT PRETRIG_VALUE
    PORT (
        clock           : IN     std_ulogic ;
        m               : IN     std_ulogic_vector (3 DOWNTO 0);
        preTrigger      : IN     std_ulogic ;
        reset           : IN     std_ulogic ;
        preTriggerValue : OUT    unsigned (7 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT cont_done
    GENERIC (
        memory_size : positive := 19;
        delay       : time     := gateDelay
    );
    PORT (
        Trigg       : IN     std_ulogic ;
        clock       : IN     std_ulogic ;
        go          : IN     std_ulogic ;
        preTriggVal : IN     unsigned (7 DOWNTO 0);
        reset       : IN     std_ulogic ;
        Memory      : OUT    unsigned (18 DOWNTO 0);
        done        : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT memory_to_process
    GENERIC (
        memory_size : positive := 19
    );
    PORT (
        clock     : IN     std_ulogic ;
        m         : IN     std_ulogic_vector (3 DOWNTO 0);
        memoryAdd : IN     unsigned (18 DOWNTO 0);
        reset     : IN     std_ulogic ;
        MISO      : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bufferUlogic
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT TFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        T   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT freqDivider
    GENERIC (
        divideValue : positive := 256;
        delay       : time     := gateDelay
    );
    PORT (
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        enable : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : ADC_TO_FPGA USE ENTITY Bachelor.ADC_TO_FPGA;
    FOR ALL : ADC_Write USE ENTITY Bachelor.ADC_Write;
    FOR ALL : FRAM_WriteRead USE ENTITY Bachelor.FRAM_WriteRead;
    FOR ALL : MAIN_MUX USE ENTITY Bachelor.MAIN_MUX;
    FOR ALL : PRETRIG_VALUE USE ENTITY Bachelor.PRETRIG_VALUE;
    FOR ALL : TFF USE ENTITY sequential.TFF;
    FOR ALL : bufferUlogic USE ENTITY gates.bufferUlogic;
    FOR ALL : cont_done USE ENTITY Bachelor.cont_done;
    FOR ALL : freqDivider USE ENTITY sequential.freqDivider;
    FOR ALL : memory_to_process USE ENTITY Bachelor.memory_to_process;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    U_6 : ADC_TO_FPGA
        GENERIC MAP (
            counter_length => 19
        )
        PORT MAP (
            clock      => clk,
            clock_1m   => meas_1mhz_internal,
            done_sig   => done,
            m          => fpga_m,
            reset      => rst,
            sdo        => adc_sdo,
            adc_clock  => adc_sclkAF,
            count_go   => count_go,
            fram_clock => fram_sclkAF,
            ncs_adc    => adc_nscAF,
            ncs_fram   => fram_ncsAF,
            sdi        => fram_sdiAF
        );
    U_0 : ADC_Write
        PORT MAP (
            FPGA_clock => fpga_sck,
            SDO        => adc_sdo,
            clock      => clk,
            m          => fpga_m,
            reset      => rst,
            AW_CLOCK   => AW_CLOCK,
            MISO       => MISO_AW,
            NCs        => adc_nscAW
        );
    U_4 : FRAM_WriteRead
        PORT MAP (
            FPGA_clock => fpga_sck,
            MOSI       => fpga_mosi,
            clock      => clk,
            m          => fpga_m,
            reset      => rst,
            NCs        => fram_ncsFW,
            SCLK_OUT   => fram_sclkFW,
            SDI        => fram_sdiFW
        );
    U_5 : MAIN_MUX
        PORT MAP (
            AF_CLOCK     => fram_sclkAF,
            AF_CLOCK_ADC => adc_sclkAF,
            AF_FRAM_SDI  => fram_sdiAF,
            AF_MISO      => MISO_AF,
            AF_NCS_A     => adc_nscAF,
            AF_NCS_F     => fram_ncsAF,
            AW_CLOCK     => AW_CLOCK,
            AW_MISO      => MISO_AW,
            AW_NCS_A     => adc_nscAW,
            FW_CLOCK     => fram_sclkFW,
            FW_FRAM_SDI  => fram_sdiFW,
            FW_NCS_F     => fram_ncsFW,
            M            => fpga_m,
            ADC_CLOCK    => adc_sclk,
            ADC_NCS      => adc_nsc,
            FRAM_SDI     => fram_sdi,
            FR_CLOCK     => fram_sclk,
            FR_NCS       => fram_ncs,
            MISO         => fpga_miso
        );
    U_12 : PRETRIG_VALUE
        PORT MAP (
            clock           => fpga_sck,
            m               => fpga_m,
            preTrigger      => acq_pretrig,
            reset           => rst,
            preTriggerValue => preTriggerValue
        );
    U_1 : cont_done
        GENERIC MAP (
            memory_size => 19,
            delay       => gateDelay
        )
        PORT MAP (
            Trigg       => acq_trig,
            clock       => clk,
            go          => count_go,
            preTriggVal => preTriggerValue,
            reset       => rst,
            Memory      => Memory,
            done        => done
        );
    U_13 : memory_to_process
        GENERIC MAP (
            memory_size => 19
        )
        PORT MAP (
            clock     => fpga_sck,
            m         => fpga_m,
            memoryAdd => Memory,
            reset     => rst,
            MISO      => MISO_AF
        );
    U_8 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => done,
            out1 => out1
        );
    U_9 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => done,
            out1 => cal(1)
        );
    U_3 : TFF
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            CLK => clk,
            CLR => rst,
            T   => T,
            Q   => meas_1mhz_internal
        );
    U_11 : TFF
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            CLK => clk,
            CLR => rst,
            T   => enable,
            Q   => sclk_meas
        );
    U_2 : freqDivider
        GENERIC MAP (
            divideValue => positive(g_clockFrequency/(2*10.0E5)),
            delay       => gateDelay
        )
        PORT MAP (
            clock  => clk,
            reset  => rst,
            enable => T
        );
    U_10 : freqDivider
        GENERIC MAP (
            divideValue => positive(g_clockFrequency/(2*32*10.0E5)),
            delay       => gateDelay
        )
        PORT MAP (
            clock  => clk,
            reset  => rst,
            enable => enable
        );

    -- Implicit buffered output assignments
    meas_1mhz <= meas_1mhz_internal;

END struct;




-- VHDL Entity Bachelor_test.mainCircuit_tester.interface
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 11:13:43 13.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
USE gates.gates.all;

ENTITY mainCircuit_tester IS
    GENERIC( 
        g_clockFrequency : real
    );
    PORT( 
        fpga_miso   : IN     std_ulogic;
        meas_1mhz   : IN     std_ulogic;
        out1        : IN     std_uLogic;
        acq_pretrig : OUT    std_ulogic;
        acq_trig    : OUT    std_ulogic;
        adc_sdo     : OUT    std_ulogic_vector (3 DOWNTO 0);
        clk         : OUT    std_uLogic;
        clk_en      : OUT    std_ulogic;
        fpga_m      : OUT    std_ulogic_vector (3 DOWNTO 0);
        fpga_mosi   : OUT    std_ulogic;
        fpga_sck    : OUT    std_ulogic;
        rst         : OUT    std_ulogic
    );

-- Declarations

END mainCircuit_tester ;





LIBRARY std;
  USE std.textio.all;
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

PACKAGE testUtils IS

  --============================================================================
  -- console output
  --

  procedure print(value : string);


  --============================================================================
  -- string manipulation
  --

                                                      -- conversion to lowercase
  function lc(value : string) return string;
  procedure lc(value : inout line);
                                                      -- conversion to uppercase
  function uc(value : string) return string;
  procedure uc(value : inout line);
                                            -- expand a string to a given length
  function pad(
    value           : string;
    string_length   : natural;
    fill_char       : character := ' ';
    right_justify   : boolean := false
  ) return string;
                     -- remove separator characters at beginning and end of line
  procedure rm_side_separators(
    value : inout line;
    separators : in string
  );
  procedure rm_side_separators(
    value : inout line
  );
                           -- remove multiple occurences of separator characters
  procedure trim_line(
    value : inout line;
    separators : in string
  );

  procedure trim_line(
    value : inout line
   );
                                -- remove all occurences of separator characters
  procedure rm_all_separators(
    value : inout line;
    separators : in string
  );

  procedure rm_all_separators(
    value : inout line
  );
                                                   -- find and remove first word
  procedure read_first(
    value : inout line;
    separators : in string;
    first : out line
  );

  procedure read_first(
    value : inout line;
    first : out line
   );
                                                    -- find and remove last word
  procedure read_last(
    value : inout line;
    separators : in string;
    last : out line
  );

  procedure read_last(
    value : inout line;
    last : out line
   );


  --============================================================================
  -- formatted string output
  --
  -- format codes:
  --  code  integer real std_logic std_(u)logic_vector (un)signed time
  --    b       v            v               v              v           binary
  --    c                                                               character
  --    d       v     v      v               v              v           decimal
  --    e                                                               real numbers, with power of 10 exponent
  --    f       v     v                                                 fixed point real numbers
  --    s                                                               string
  --    ts                                                          v   time in seconds
  --    tm                                                          v   time in milliseconds
  --    tu                                                          v   time in microseconds
  --    tn                                                          v   time in nanoseconds
  --    tp                                                          v   time in picoseconds
  --    x       v            v               v              v           hexadecimal
  --    X       v            v               v              v           hexadecimal with upper-case letters

  function sprintf(format : string; value : integer          ) return string;
  function sprintf(format : string; value : real             ) return string;
  function sprintf(format : string; value : std_logic        ) return string;
  function sprintf(format : string; value : std_ulogic_vector) return string;
  function sprintf(format : string; value : std_logic_vector ) return string;
  function sprintf(format : string; value : unsigned         ) return string;
  function sprintf(format : string; value : signed           ) return string;
  function sprintf(format : string; value : time             ) return string;

  --============================================================================
  -- formatted string input
  --
  subtype nibbleUlogicType is std_ulogic_vector(3 downto 0);
  subtype nibbleUnsignedType is unsigned(3 downto 0);

  function sscanf(value : character) return natural;
  function sscanf(value : character) return nibbleUlogicType;
  function sscanf(value : character) return nibbleUnsignedType;
  function sscanf(value : string   ) return natural;
  function sscanf(value : string   ) return unsigned;
  function sscanf(value : string   ) return std_ulogic_vector;
  function sscanf(value : string   ) return time;

  procedure sscanf(value : inout line; time_val : out time);

END testUtils;




PACKAGE BODY testUtils IS

  --============================================================================
  -- console output
  --

  procedure print(value : string) is
    variable my_line : line;
  begin
    write(my_line, value);
    writeLine(output, my_line);
    deallocate(my_line);
  end print;


  --============================================================================
  -- string manipulation
  --

  ------------------------------------------------------------------------------
  -- change to lowercase
  ------------------------------------------------------------------------------
  procedure lc(value: inout line) is
    variable out_line: line;
  begin
    for index in value'range loop
      if (value(index) >= 'A') and (value(index) <= 'Z') then
        value(index) := character'val(character'pos(value(index))
                                    - character'pos('A')
                                    + character'pos('a')
                                      );
      end if;
    end loop;
  end lc;

  function lc(value: string) return string is
    variable out_line: line;
  begin
    write(out_line, value);
    lc(out_line);
    return(out_line.all);
  end lc;

  ------------------------------------------------------------------------------
  -- change to uppercase
  ------------------------------------------------------------------------------
  procedure uc(value: inout line) is
    variable out_line: line;
  begin
    for index in value'range loop
      if (value(index) >= 'a') and (value(index) <= 'z') then
        value(index) := character'val(character'pos(value(index))
                                    - character'pos('a')
                                    + character'pos('A')
                                      );
      end if;
    end loop;
  end uc;

  function uc(value: string) return string is
    variable out_line: line;
  begin
    write(out_line, value);
    uc(out_line);
    return(out_line.all);
  end uc;

  ------------------------------------------------------------------------------
  -- formatted string output: padding and justifying
  ------------------------------------------------------------------------------
  function pad(
    value           : string;
    string_length   : natural;
    fill_char       : character := ' ';
    right_justify   : boolean := false
  ) return string is
    variable value_line : line;
    variable out_line : line;
    variable value_length : natural;
    variable shift_sign : boolean;
  begin
    write(value_line, value);
    value_length := value_line.all'length;
    if string_length = 0 then
      write(out_line, value_line.all);
    elsif string_length > value_length then
      if right_justify then
        if (value_line.all(value_line.all'left) <= '-') and not(fill_char = ' ') then
          shift_sign := true;
          write(out_line, value_line.all(value_line.all'left));
        end if;
        for index in 1 to string_length-value_length loop
          write(out_line, fill_char);
        end loop;
      end if;
      if shift_sign then
        write(out_line, value_line.all(value_line.all'left+1 to value_line.all'right));
      else
        write(out_line, value_line.all);
      end if;
      if not right_justify then
        for index in 1 to string_length-value_length loop
          write(out_line, fill_char);
        end loop;
      end if;
    elsif string_length < value_length then
      write(out_line, '#');
      write(out_line, value_line.all(value_length-string_length+2 to value_length));
    else
      write(out_line, value_line.all);
    end if;
    deallocate(value_line);
    return(out_line.all);
  end pad;

  ------------------------------------------------------------------------------
  -- remove separator characters at beginning and end of line
  ------------------------------------------------------------------------------
  procedure rm_side_separators(
    value : inout line;
    separators : in string
  ) is
    variable input_line : line    := value;
    variable found      : boolean := false;
    variable position   : integer := 0;
  begin
    -- remove all separators in the beginning
    position := -1;
    for character_index in input_line'range loop
      found := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          found := true;
        end if;
      end loop;
      if found then
          position := character_index;
      else
          exit;
      end if;
   end loop;
   if position > -1 then
     input_line := new string'( input_line(position+1 to input_line'right) );
   end if;

   -- remove all separators in the end
    position := -1;
    for character_index in input_line'reverse_range loop
      found := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          found := true;
        end if;
      end loop;
      if found then
          position := character_index;
      else
          exit;
      end if;
   end loop;
   if position > -1 then
     input_line := new string'( input_line(input_line'left to position-1) );
   end if;

   value := input_line;
  end;

  procedure rm_side_separators(value : inout line) is
  begin
    rm_side_separators(value, " :" & ht);
  end;

  ------------------------------------------------------------------------------
  -- remove multiple occurences of separator characters, keeping one single
  ------------------------------------------------------------------------------
  procedure trim_line(
    value : inout line;
    separators : in string
  ) is
    variable input_line: line := value;
    variable output_line: line := new string'("");
    variable is_separator, was_separator : boolean := false;
  begin
    rm_side_separators(input_line);
    for character_index in input_line'range loop
      is_separator := false;
      for separator_index in separators'range loop
        if input_line.all(character_index) = separators(separator_index) then
          is_separator := true;
        end if;
      end loop;
      if not (is_separator and was_separator) then
        write(output_line, input_line.all(character_index));
      end if;
      was_separator := is_separator;
    end loop;

    value := output_line;
  end;

  procedure trim_line(value : inout line) is
  begin
    trim_line(value, " :" & ht);
  end;

  ------------------------------------------------------------------------------
  -- remove all occurences of separator characters
  ------------------------------------------------------------------------------
  procedure rm_all_separators(
    value : inout line;
    separators : in string
  ) is
    variable input_line   : line    := value;
    variable is_separator : boolean := false;
  begin

    -- remove separators from beginn and end of the line
    -- rm_separator_be(value, separators);

    -- empty output line
    value := new string'("");

    -- find all separator symbols
    for character_index in input_line'range loop
      is_separator := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          is_separator := true;
        end if;
      end loop;
      if not is_separator then
        write(value, input_line.all(character_index));
      end if;
    end loop;

  end;

  procedure rm_all_separators(value : inout line) is
  begin
    rm_all_separators(value, " _." & ht);
  end;

  ------------------------------------------------------------------------------
  -- read first "word" out of a line
  ------------------------------------------------------------------------------
  procedure read_first(
    value : inout line;
    separators : in string;
    first : out line
  ) is
    variable input_line: line;
    variable position: natural := 0;
  begin
    input_line := value;
    for character_index in input_line.all'reverse_range loop
      for separator_index in separators'range loop
        if input_line.all(character_index) = separators(separator_index) then
          position := character_index;
        end if;
      end loop;
    end loop;
    if position > 1 then
      first := new string'(input_line.all(input_line'left to position-1));
	    value := new string'(input_line(position+1 to input_line'right));
    else
      first := new string'(input_line.all);
	    value := new string'("");
    end if;
  end;

  procedure read_first(value : inout line; first : out line) is
  begin
    read_first(value, " :" & ht, first);
  end;

  ------------------------------------------------------------------------------
  -- read last "word" out of a line
  ------------------------------------------------------------------------------
  procedure read_last(
    value : inout line;
    separators : in string;
    last : out line
  ) is
    variable input_line: line := value;
    variable position: natural := 0;
  begin
    for character_index in input_line'range loop
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          position := character_index;
        end if;
      end loop;
    end loop;
    if position <= input_line'right and
       position >  0                then
      value := new string'(input_line(input_line'left to position-1));
      last  := new string'(input_line(position+1 to input_line'right));
    else
      last := new string'(input_line.all);
    end if;
  end;

  procedure read_last(value : inout line; last : out line) is
  begin
    read_last(value, " :" & ht, last);
  end;


  --============================================================================
  -- formatted string output, internal functions
  --

  ------------------------------------------------------------------------------
  -- get format specification
  ------------------------------------------------------------------------------
  procedure get_format_items(
    format          : string;
    right_justify   : out boolean;
    add_sign        : out boolean;
    fill_char       : out character;
    total_length    : out natural;
    point_precision : out natural;
    format_type     : inout line
  ) is
    variable find_sign : boolean := false;
    variable find_padding : boolean := false;
    variable find_length : boolean := false;
    variable find_precision : boolean := false;
    variable find_type : boolean := false;
    variable right_justify_int : boolean := true;
    variable total_length_int : natural := 0;
    variable point_precision_int : natural := 0;
  begin
    add_sign := false;
    fill_char := ' ';
    for index in 1 to format'length loop
      if find_type then
        write(format_type, format(index));
      end if;
      if find_precision then
        if (format(index) >= '0') and (format(index) <= '9') then
          point_precision_int := 10*point_precision_int + character'pos(format(index)) - character'pos('0');
          if format(index+1) >= 'A' then
            find_precision := false;
            find_type := true;
          end if;
        end if;
      end if;
      if find_length then
        if (format(index) >= '0') and (format(index) <= '9') then
          total_length_int := 10*total_length_int + character'pos(format(index)) - character'pos('0');
        end if;
        if format(index) = '.' then
          find_length := false;
          find_precision := true;
        elsif format(index+1) >= 'A' then
          find_length := false;
          find_type := true;
        end if;
      end if;
      if find_padding then
        if format(index) = '0' then
          if right_justify_int then
            fill_char := '0';
          end if;
        end if;
        find_padding := false;
        if format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
      if find_sign then
        if format(index) = '-' then
          right_justify_int := false;
        end if;
        if format(index) = '+' then
          add_sign := true;
        end if;
        find_sign := false;
        if format(index+1) <= '-' then
          find_sign := true;
        elsif format(index+1) = '0' then
          find_padding := true;
        elsif format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
      if format(index) = '%' then
        if format(index+1) <= '-' then
          find_sign := true;
        elsif format(index+1) = '0' then
          find_padding := true;
        elsif format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
    end loop;
    right_justify := right_justify_int;
    total_length := total_length_int;
    point_precision := point_precision_int;
  end get_format_items;


  ------------------------------------------------------------------------------
  -- formatted string output: converting std_ulogic to character
  ------------------------------------------------------------------------------
  function to_character(value: std_ulogic) return character is
    variable out_value: character;
  begin
    case value is
      when 'U' => out_value := 'U';
      when 'X' => out_value := 'X';
      when '0' => out_value := '0';
      when '1' => out_value := '1';
      when 'Z' => out_value := 'Z';
      when 'W' => out_value := 'W';
      when 'L' => out_value := 'L';
      when 'H' => out_value := 'H';
      when '-' => out_value := '-';
    end case;
    return(out_value);
  end to_character;

  ------------------------------------------------------------------------------
  -- formatted string output: binary integer
  ------------------------------------------------------------------------------
  function sprintf_b(value: std_ulogic_vector) return string is
    variable out_line : line;
  begin
    for index in value'range loop
      write(out_line, to_character(value(index)));
    end loop;
    return(out_line.all);
  end sprintf_b;

  ------------------------------------------------------------------------------
  -- formatted string output: decimal integer
  ------------------------------------------------------------------------------
  function sprintf_d(
    right_justify   : boolean;
    add_sign        : boolean;
    fill_char       : character;
    string_length   : natural;
    value           : integer
  ) return string is
    variable value_line : line;
  begin
    if add_sign and (value >= 0) then
      write(value_line, '+');
    end if;
    write(value_line, value);
    if string_length = 0 then
      return(value_line.all);
    else
      return(pad(value_line.all, string_length, fill_char, right_justify));
    end if;
  end sprintf_d;

  ------------------------------------------------------------------------------
  -- formatted string output: fixed point real
  ------------------------------------------------------------------------------
  function sprintf_f(
    right_justify   : boolean;
    add_sign        : boolean;
    fill_char       : character;
    string_length   : natural;
    point_precision : natural;
    value           : real
  ) return string is
    variable point_precision_int : natural;
    variable integer_part : integer;
    variable decimal_part : natural;
    variable value_line : line;
  begin
    if point_precision = 0 then
      point_precision_int := 6;
    else
      point_precision_int := point_precision;
    end if;
    if value >= 0.0 then
      integer_part := integer(value-0.5);
    else
      integer_part := - integer(-value-0.5);
    end if;
    decimal_part := abs(integer((value-real(integer_part))*(10.0**point_precision_int)));
    if add_sign and (value >= 0.0) then
      write(value_line, '+');
    end if;
    write(value_line, integer_part);
    write(value_line, '.');
    write(value_line, sprintf_d(true, false, '0', point_precision_int, decimal_part));
    if string_length = 0 then
      return(value_line.all);
    else
      return(pad(value_line.all, string_length, fill_char, right_justify));
    end if;
  end sprintf_f;

  ------------------------------------------------------------------------------
  -- formatted string output: hexadecimal integer
  ------------------------------------------------------------------------------
  function sprintf_X(
    extend_unsigned : boolean;
    value           : std_ulogic_vector
  ) return string is
    variable bit_count : positive;
    variable value_line : line;
    variable out_line : line;
    variable nibble: string(1 to 4);
  begin
    bit_count := value'length;
    while (bit_count mod 4) /= 0 loop
      if extend_unsigned then
        write(value_line, to_character('0'));
      else
        write(value_line, to_character(value(value'high)));
      end if;
      bit_count := bit_count + 1;
    end loop;
    write(value_line, sprintf_b(value));
    for index in value_line.all'range loop
      if (index mod 4) = 0 then
        nibble := value_line.all(index-3 to index);
        case nibble is
          when "0000" => write(out_line, 0);
          when "0001" => write(out_line, 1);
          when "0010" => write(out_line, 2);
          when "0011" => write(out_line, 3);
          when "0100" => write(out_line, 4);
          when "0101" => write(out_line, 5);
          when "0110" => write(out_line, 6);
          when "0111" => write(out_line, 7);
          when "1000" => write(out_line, 8);
          when "1001" => write(out_line, 9);
          when "1010" => write(out_line, 'A');
          when "1011" => write(out_line, 'B');
          when "1100" => write(out_line, 'C');
          when "1101" => write(out_line, 'D');
          when "1110" => write(out_line, 'E');
          when "1111" => write(out_line, 'F');
          when others => write(out_line, 'X');
        end case;
      end if;
    end loop;
    return(out_line.all);
  end sprintf_X;


  --============================================================================
  -- formatted string output, interface functions
  --

  ------------------------------------------------------------------------------
  -- integer
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : integer) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if format_type.all = "b" then
      if string_length = 0 then
        string_length := 8;
      end if;
      return(sprintf_b(std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0))));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, string_length, value));
    elsif format_type.all = "f" then
      return(sprintf_f(right_justify, add_sign, fill_char,
                       string_length, point_precision, real(value)));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if string_length = 0 then
        string_length := 8;
      end if;
      string_length := 4*string_length;
      if format_type.all = "X" then
        return(sprintf_X(false, std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0))));
      else
        return(lc(sprintf_X(false, std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0)))));
      end if;
    else
      return("Unhandled format type: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- real
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : real) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "d") or (point_precision = 0) then
      return(sprintf_d(right_justify, add_sign, fill_char,
                       string_length, integer(value)));
    elsif format_type.all = "f" then
      return(sprintf_f(right_justify, add_sign, fill_char,
                       string_length, point_precision, value));
    else
      return("Unhandled format type: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_logic
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_logic) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
    variable logic_vector: std_logic_vector(1 to 1);
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      logic_vector(1) := value;
      return(sprintf(format, std_ulogic_vector(logic_vector)));
    else
      return("Not a std_logic format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_ulogic_vector
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_ulogic_vector) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable bit_string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     bit_string_length, point_precision, format_type);
    if format_type.all = "b" then
      return(pad(sprintf_b(value), bit_string_length, fill_char, right_justify));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, bit_string_length, to_integer(unsigned(value))));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if format_type.all = "X" then
        return(pad(sprintf_X(true, value), bit_string_length, fill_char, right_justify));
      else
        return(lc(pad(sprintf_X(true, value), bit_string_length, fill_char, right_justify)));
      end if;
    else
      return("Not a std_ulogic_vector format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_logic_vector
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_logic_vector) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      return(sprintf(format, std_ulogic_vector(value)));
    else
      return("Not a std_logic_vector format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- unsigned
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : unsigned) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      return(sprintf(format, std_ulogic_vector(value)));
    else
      return("Not an unsigned format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- signed
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : signed) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable bit_string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     bit_string_length, point_precision, format_type);
    if (fill_char = '0') and (value(value'left) = '1') then
      fill_char := '1';
    end if;
    if format_type.all = "b" then
      return(pad(sprintf_b(std_ulogic_vector(value)), bit_string_length, fill_char, right_justify));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, bit_string_length, to_integer(signed(value))));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if fill_char = '1' then
        fill_char := 'F';
      end if;
      if format_type.all = "X" then
        return(pad(sprintf_X(true, std_ulogic_vector(value)), bit_string_length, fill_char, right_justify));
      else
        return(lc(pad(sprintf_X(true, std_ulogic_vector(value)), bit_string_length, fill_char, right_justify)));
      end if;
    else
      return("Not a signed format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- time
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : time) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
    variable scaling : real;
    variable base_time : time;
    variable unit : string(1 to 3);
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if format_type.all(format_type.all'left) = 't' then
      scaling := 10.0**point_precision;
      if format_type.all = "tp" then
        base_time := 1 ps;
        unit := " ps";
      elsif format_type.all = "tn" then
        base_time := 1 ns;
        unit := " ns";
      elsif format_type.all = "tu" then
        base_time := 1 us;
        unit := " us";
      elsif format_type.all = "tm" then
        base_time := 1 ms;
        unit := " ms";
      elsif format_type.all = "ts" then
        base_time := 1 sec;
        unit := " s.";
      else
        return("Undefined time format: '" & format_type.all & "'");
      end if;
      if point_precision = 0 then
        return(sprintf_d(right_justify, add_sign, fill_char,
                         string_length, value/base_time) & unit);
      else
        return(sprintf_f(right_justify, add_sign, fill_char, string_length,
                         point_precision, real(scaling*value/base_time)/scaling) & unit);
      end if;
    else
      return("Not a time format: '" & format_type.all & "'");
    end if;
  end sprintf;


  --============================================================================
  -- formatted string input
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- read a nibble out of a character
  ------------------------------------------------------------------------------
  function sscanf(value : character) return natural is
  begin
    if (value >= '0') and (value <= '9') then
      return(character'pos(value) - character'pos('0'));
    elsif (value >= 'a') and (value <= 'f') then
      return(character'pos(value) - character'pos('a') + 10);
    elsif (value >= 'A') and (value <= 'F') then
      return(character'pos(value) - character'pos('A') + 10);
    else
      return(0);
    end if;
  end sscanf;

  function sscanf(value : character) return nibbleUnsignedType is
  begin
    return(to_unsigned(sscanf(value), nibbleUnsignedType'length));
  end sscanf;

  function sscanf(value : character) return nibbleUlogicType is
    variable unsigned_value : nibbleUnsignedType;
  begin
    unsigned_value := sscanf(value);
    return(std_ulogic_vector(unsigned_value));
  end sscanf;

  ------------------------------------------------------------------------------
  -- read an binary word out of a string
  ------------------------------------------------------------------------------
  function sscanf(value : string) return natural is
    variable integer_value : natural;
  begin
    integer_value := 0;
    for index in value'left to value'right loop
      integer_value := integer_value*16 + sscanf(value(index));
    end loop;
    return(integer_value);
  end;

  function sscanf(value : string) return unsigned is
    variable unsigned_value : unsigned(4*value'length-1 downto 0);
  begin
    unsigned_value := to_unsigned(0,unsigned_value'length);
    for index in value'left to value'right loop
      unsigned_value := shift_left(unsigned_value,4) + to_unsigned(sscanf(value(index)),4);
    end loop;
    return(unsigned_value);
  end;

  function sscanf(value : string) return std_ulogic_vector is
    variable unsigned_value : unsigned(4*value'length-1 downto 0);
  begin
    unsigned_value := sscanf(value);
    return(std_ulogic_vector(unsigned_value));
  end;

  ------------------------------------------------------------------------------
  -- read time from a string
  -- time can be formated as follows:
  --   "1ps" or "1 ps" or " 1 ps " or " 1ps"
  -- possible time units are: hr, min, sec, ms, us, ns, ps, fs
  ------------------------------------------------------------------------------
  procedure sscanf(
     value    : inout line;
     time_val : out time
  ) is
      variable time_line  : line := value;
      variable time_base  : string(1 to 3);
      variable time_value : integer;
      variable time_int   : time;
  begin
    -- remove all spaces and tabs
    rm_all_separators(time_line);

    -- strip time base (3 last characters)
    time_base := time_line(time_line'right-2 to time_line'right);

    -- separate time value and base
    if time_base(2 to 3) = "hr" then
        time_int   := 1 hr;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base = "min" then
        time_int   := 1 min;
        time_value := integer'value(time_line(time_line'left to time_line'right -3));
    elsif time_base = "sec" then
        time_int   := 1 sec;
        time_value := integer'value(time_line(time_line'left to time_line'right -3));
    elsif time_base(2 to 3) = "ms" then
        time_int   := 1 ms;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "us" then
        time_int   := 1 us;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "ns" then
        time_int   := 1 ns;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "ps" then
        time_int   := 1 ps;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "fs" then
        time_int   := 1 fs;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    else
        time_int   := 0 ps;
        time_value := 1;
    end if;

    -- build time from value and base
    time_val := time_int * time_value;

  end;

  function sscanf(value : string) return time is
    variable value_line : line;
    variable time_val   : time;
  begin
    value_line := new string'(value);
    sscanf(value_line, time_val);
    return(time_val);
  end;

END testUtils;




LIBRARY std;
  USE std.textio.ALL;

LIBRARY ieee;
  USE ieee.std_logic_textio.ALL;

LIBRARY Common_test;
  USE Common_test.testutils.all;

ARCHITECTURE test OF mainCircuit_tester IS

  constant clockPeriodInn  : time := 1.0/g_clockFrequency * 1 sec;
  constant clockPeriod  : time := 2.0/g_clockFrequency * 1 sec;
  signal sClock         : std_uLogic := '1';
  signal sReset         : std_uLogic ;
  signal testInfo       : string(1 to 40) := (others => ' ');

  signal counter_test        : unsigned(5 downto 0);
  signal trigger_counter     : unsigned(18 downto 0);

  signal sClock_fpga         : std_uLogic := '1';
  constant value_8           : natural := 8;
  constant value_16          : natural := 16;
  constant value_19          : natural := 19;
  constant value_32          : natural := 32;

  signal ADC_WRITE_INIT      : unsigned(15 downto 0);
  signal count_miso          : unsigned(5 downto 0);
  signal FRAM_WREN_INIT      : unsigned(7 downto 0);
  signal FRAM_WRDI_INIT      : unsigned(7 downto 0);
  signal pretrigVal          : unsigned(7 downto 0);
  signal count_memoryMax     : unsigned(18 downto 0);
  signal count_memory        : unsigned(18 downto 0);
  signal FRAM_READ_INIT      : unsigned(31 downto 0);
  signal FRAM_READ_ADD       : unsigned(18 downto 0);
  signal FRAM_WRITE_INIT     : unsigned(31 downto 0);
  signal init_done           : std_uLogic ;
  signal miso_start          : std_uLogic ;
  signal clk_start          : std_uLogic ;
  signal selector            : unsigned(3 downto 0); 

  -- An example of procedure (function which returns nothing)
  -- Here checks a value and log given error message if sim is not the same
  procedure checkMeas(
    msg :           string;
    measArg :       std_ulogic) is
  begin

    std.textio.write(std.textio.output, LF & "===================" & LF);
    std.textio.write(std.textio.output, "Testing " & msg  & LF);

    assert (meas_1mhz = measArg)
      report ("meas_1mhz error - expected " & to_string(measArg)) severity error;
    if (meas_1mhz = measArg) then
      report " ** Ok" severity note;
    end if;

    std.textio.write(std.textio.output, "===================" & LF);

    -- Force clock synch.
    wait until clk'event and clk = '1';
  end procedure checkMeas;

BEGIN

 ------------------------------------------------------------------------------
                                                              -- reset and clock
  rst <= sReset;

  sClock <= not sClock after clockPeriodInn/2;
  clk <= sClock;

  

  sClock_fpga <= not sClock_fpga after clockPeriod/2;
  fpga_sck <= sClock_fpga ;

  ------------------------------------------------------------------------------
                                                              -- tester
  process
    variable state : std_ulogic := '0';
  begin
    -- Outputs default values
    sReset <= '1';
    acq_pretrig <= '0';
    acq_trig <= '0';
    adc_sdo <= (others => '1');
    fpga_m <= (others => '0');
    fpga_mosi <= '0';
    clk_en <= '0';
    clk_start <= '0';
  --------------------------------------------------------------------------------
                                                                -- TESTER_MCU  
    counter_test <= (others => '0');
    count_memory <= (others => '0');
    count_memoryMax <= (others => '1');
    ADC_WRITE_INIT <= "1010001010000000"; --1 010 00 10 10000000
    FRAM_READ_INIT <= SHIFT_LEFT(RESIZE("0000001100000",FRAM_READ_INIT),19);
    FRAM_WRDI_INIT <= "00000100";
    FRAM_WREN_INIT <= "00000110";
    pretrigVal <= "11010000";
    FRAM_WRITE_INIT <= SHIFT_LEFT(RESIZE("0000001000000",FRAM_READ_INIT),19);
    init_done <= '0';
    miso_start <= '0';
    selector <= (others => '0');
    count_miso <= (others => '0');
    FRAM_READ_ADD <= (others => '0');

    testInfo <= pad("Init", testInfo'length);
    wait for 20*clockPeriod;
    sReset <= '0';
    wait until rising_edge(sClock_fpga);

    while true loop
      -- Wait until toggler should toggle
      wait for clockPeriod;
      

      if selector = "0000" then
        selector <= "1110";

      elsif selector = "1110" then
        fpga_m <= "1110";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        acq_pretrig <= pretrigVal(pretrigVal'high);
        pretrigVal <= SHIFT_LEFT(pretrigVal,1);
        counter_test <= counter_test+1 ;
          if counter_test = value_8 then
            counter_test <= (others => '0');
            clk_start <= '0';
            selector <= "0001";
          end if ;

      elsif selector = "0001" then
        fpga_m <= "0001";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        fpga_mosi <= ADC_WRITE_INIT(ADC_WRITE_INIT'HIGH);
        ADC_WRITE_INIT <= SHIFT_LEFT(ADC_WRITE_INIT,1);
        counter_test <= counter_test +1;
        if counter_test = value_16-1 then
          counter_test <= (others => '0');
          clk_start <= '0';
          selector <= "1000";
        end if ;

      elsif selector = "1000" then
        fpga_m <= "1000";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        if init_done <= '0' then
          fpga_mosi <= FRAM_WREN_INIT(FRAM_WREN_INIT'high);
          FRAM_WREN_INIT <= SHIFT_LEFT(FRAM_WREN_INIT,1);
          counter_test <= counter_test +1;
          if counter_test = value_8-1 then
            counter_test <= (others => '0');
            clk_start <= '0';
            selector <= "1111";
          end if ;
        else
          fpga_mosi <= FRAM_WRITE_INIT(FRAM_WRITE_INIT'high);
          FRAM_WRITE_INIT <= SHIFT_LEFT(FRAM_WRITE_INIT,1);
          counter_test <= counter_test +1;
          if counter_test = value_32-1 then
            counter_test <= (others => '0');
            clk_start <= '0';
            selector <= "1010";
          end if ;
        end if ;

      elsif selector = "1111" then
        fpga_m <= "1111";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        counter_test <= counter_test +1;
          if counter_test = value_8-1 then
            counter_test <= (others => '0');
            init_done <= '1';
            clk_start <= '0';
            selector <= "1000";
          end if ;

      elsif selector = "1010" then
        fpga_m <= "1010";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        count_memory <= count_memory+1;
        if count_memory = count_memoryMax then
          acq_trig <= '1';
        end if ;
        if out1 = '1' then
          clk_start <= '0';
          selector <= "1011";
        end if ;

      elsif selector = "1011" then
        fpga_m <= "1011";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        if fpga_miso = '1' and miso_start = '0' then
          --count_miso <= count_miso+1;
          miso_start <= '1';
          acq_trig <= '0';
        elsif miso_start = '1' and count_miso <19 then
          count_miso <= count_miso+1;
          FRAM_READ_ADD <= SHIFT_LEFT(FRAM_READ_ADD,1);
          FRAM_READ_ADD(0) <= fpga_miso;
        elsif count_miso = 19 and miso_start = '1' then
          miso_start <= '0';
          count_miso <= (others => '0');
          FRAM_READ_INIT <= RESIZE(FRAM_READ_INIT+
                            RESIZE(FRAM_READ_ADD,
                              FRAM_READ_INIT),
                            FRAM_READ_INIT);
          clk_start <= '0';
          selector <= "0100";
        end if;

      elsif selector = "0100" then
        fpga_m <= "0100";
        if clk_start = '0' then
          wait for clockPeriod;
          clk_start <= '1';
        end if;
        fpga_mosi <= FRAM_READ_INIT(FRAM_READ_INIT'high);
        FRAM_READ_INIT <= SHIFT_LEFT(FRAM_READ_INIT,1);
      end if ;
      -- Invert state and loop
      state := not state;

    end loop;

  end process;

END ARCHITECTURE test;




--
-- VHDL Architecture Bachelor_test.mainCircuit_tb.struct
--
-- Created:
--          by - christop.grobety.UNKNOWN (WE2332207)
--          at - 11:13:43 13.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY Bachelor;
LIBRARY Bachelor_test;

ARCHITECTURE struct OF mainCircuit_tb IS

    -- Architecture declarations
    constant c_clockFrequency : real := 64.0E6;

    -- Internal signal declarations
    SIGNAL acq_pretrig : std_ulogic;
    SIGNAL acq_trig    : std_ulogic;
    SIGNAL adc_sdo     : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL clk         : std_uLogic;
    SIGNAL clk_en      : std_ulogic;
    SIGNAL fpga_m      : std_ulogic_vector(3 DOWNTO 0);
    SIGNAL fpga_miso   : std_ulogic;
    SIGNAL fpga_mosi   : std_ulogic;
    SIGNAL fpga_sck    : std_ulogic;
    SIGNAL meas_1mhz   : std_ulogic;
    SIGNAL out1        : std_uLogic;
    SIGNAL rst         : std_ulogic;


    -- Component Declarations
    COMPONENT mainCircuit
    GENERIC (
        g_clockFrequency : real := 64.0E6
    );
    PORT (
        acq_pretrig : IN     std_ulogic ;
        acq_trig    : IN     std_ulogic ;
        adc_sdo     : IN     std_ulogic_vector (3 DOWNTO 0);
        clk         : IN     std_ulogic ;
        clk_en      : IN     std_ulogic ;
        fpga_m      : IN     std_ulogic_vector (3 DOWNTO 0);
        fpga_mosi   : IN     std_ulogic ;
        fpga_sck    : IN     std_ulogic ;
        rst         : IN     std_uLogic ;
        adc_nsc     : OUT    std_ulogic ;
        adc_sclk    : OUT    std_ulogic ;
        cal         : OUT    std_ulogic_vector (2 DOWNTO 1);
        fpga_miso   : OUT    std_ulogic ;
        fram_ncs    : OUT    std_ulogic_vector (3 DOWNTO 0);
        fram_sclk   : OUT    std_ulogic_vector (3 DOWNTO 0);
        fram_sdi    : OUT    std_ulogic_vector (3 DOWNTO 0);
        meas_1mhz   : OUT    std_ulogic ;
        out1        : OUT    std_uLogic ;
        sclk_meas   : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT mainCircuit_tester
    GENERIC (
        g_clockFrequency : real
    );
    PORT (
        fpga_miso   : IN     std_ulogic ;
        meas_1mhz   : IN     std_ulogic ;
        out1        : IN     std_uLogic ;
        acq_pretrig : OUT    std_ulogic ;
        acq_trig    : OUT    std_ulogic ;
        adc_sdo     : OUT    std_ulogic_vector (3 DOWNTO 0);
        clk         : OUT    std_uLogic ;
        clk_en      : OUT    std_ulogic ;
        fpga_m      : OUT    std_ulogic_vector (3 DOWNTO 0);
        fpga_mosi   : OUT    std_ulogic ;
        fpga_sck    : OUT    std_ulogic ;
        rst         : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : mainCircuit USE ENTITY Bachelor.mainCircuit;
    FOR ALL : mainCircuit_tester USE ENTITY Bachelor_test.mainCircuit_tester;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I_dut : mainCircuit
        GENERIC MAP (
            g_clockFrequency => c_clockFrequency
        )
        PORT MAP (
            acq_pretrig => acq_pretrig,
            acq_trig    => acq_trig,
            adc_sdo     => adc_sdo,
            clk         => clk,
            clk_en      => clk_en,
            fpga_m      => fpga_m,
            fpga_mosi   => fpga_mosi,
            fpga_sck    => fpga_sck,
            rst         => rst,
            adc_nsc     => OPEN,
            adc_sclk    => OPEN,
            cal         => OPEN,
            fpga_miso   => fpga_miso,
            fram_ncs    => OPEN,
            fram_sclk   => OPEN,
            fram_sdi    => OPEN,
            meas_1mhz   => meas_1mhz,
            out1        => out1,
            sclk_meas   => OPEN
        );
    I_tester : mainCircuit_tester
        GENERIC MAP (
            g_clockFrequency => c_clockFrequency
        )
        PORT MAP (
            fpga_miso   => fpga_miso,
            meas_1mhz   => meas_1mhz,
            out1        => out1,
            acq_pretrig => acq_pretrig,
            acq_trig    => acq_trig,
            adc_sdo     => adc_sdo,
            clk         => clk,
            clk_en      => clk_en,
            fpga_m      => fpga_m,
            fpga_mosi   => fpga_mosi,
            fpga_sck    => fpga_sck,
            rst         => rst
        );

END struct;




